#2.1 Exploratory data analysis
#2.1.1.1 - Statistics summary
dim(brooklyn_2016_2020_final)
summary(brooklyn_2016_2020_final)
#2.1.1.2 - Check for any NA’s in the dataframe
missmap(
brooklyn_2016_2020_final,
col=c('yellow','black'),
y.at=1,
y.labels='',legend=TRUE
)
colSums(is.na(brooklyn_2016_2020_final))
#2.1.1.3 - Data Cleansing — Handle missing data
brooklyn_2016_2020_final[["taxclasscurr"]][
str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^A")
& is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 1
brooklyn_2016_2020_final[["taxclasscurr"]][
str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^R")
& is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 2
brooklyn_2016_2020_final[["comunits"]][
is.na(brooklyn_2016_2020_final[["comunits"]])] <- 0
#2.1.1.4 - Correlations
#A positive correlation indicates the extent to which those variables
# increase or decrease in parallel;
#a negative correlation indicates the extent to which one variable
#increases as the other decreases.
ggcorr(
brooklyn_2016_2020_final,
label = T, hjust = 1,
legend.position="top",
layout.exp = 1
)
#The correlation between each independent variable with the target
# variable must not be weak.
#However, the correlation between two independent variables must not
# be too strong. Multicollinearity occurs
#when independent variables in a regression model are correlated.
#This correlation is a problem because
#independent variables should be independent. If the degree of
#correlation between variables is high enough,
#it can cause problems when you fit the model and interpret the results.
#By looking at the correlation coefficient of the independent
#variables 'taxclasscurr', 'taxclasssale'
#'landsqft', 'lot' with the target variable 'price'
#'(0.1, 0.1, 0.1, 0.1 respectively) are weak correlations,
#'therefore we can exclude these two independent variable from our model.
#2.1.1.5 - visualizing the distribution of the target variable 'price'
brooklyn_2016_2020_final %>%
ggplot(aes(price)) +
stat_density() +
theme_bw()
#2.1.3.1 - Additionally restrict the data to observation where
#price is greater than 0
brooklyn_2016_2020_final <-
brooklyn_2016_2020_final %>% filter(price > 0 & !is.na(price))
#2.1.3.2 - Additionally restrict the data to observation where
#zip is greater than 0
brooklyn_2016_2020_final <-
brooklyn_2016_2020_final %>% filter(zip > 0)
#2.1.3.3 - visualizing the distribution of the target variable 'price'
brooklyn_2016_2020_final %>%
ggplot(aes(price)) +
stat_density() +
theme_bw()
#2.1.3.4 - Create a histogram of housing prices
ggplot(data=brooklyn_2016_2020_final) +
geom_histogram(mapping = aes(price))
ggplot(data=brooklyn_2016_2020_final) +
geom_histogram(mapping = aes(price/100000),
breaks=seq(0, 7, by = 1), col="red", fill="lightblue") +
geom_density(mapping = aes(x=price/100000, y = (..count..)))  +
labs(title="Housing Prices in Brooklyn, NY (in $100,000)",
x="Sale Price of Individual Homes/Condos")
ggplot(data=brooklyn_2016_2020_final) +
geom_point(mapping= aes(x=grosssqft, y=price))
ggplot(data=brooklyn_2016_2020_final) +
geom_point(mapping= aes(x=log(grosssqft), y=price))
ggplot(data=brooklyn_2016_2020_final) +
geom_point(mapping= aes(x=yrbuilt, y=price))
ggplot(data=brooklyn_2016_2020_final) +
geom_point(mapping= aes(x=price, y=bldclasssale))
ggplot(data=brooklyn_2016_2020_final) +
geom_point(mapping= aes(x=price, y=zip))
ggplot(data=brooklyn_2016_2020_final) +
geom_point(mapping= aes(x=price, y=block))
ggplot(data=brooklyn_2016_2020_final) +
geom_point(mapping= aes(x=price, y=neighborhood))
#2.1.3.5 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
zip,
neighborhood,
block,
grosssqft,
landsqft,
yrbuilt,
bldclasssale,
taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
#2.1.1.6 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(
c(price,
zip,
neighborhood,
block,
grosssqft,
landsqft,
yrbuilt,
bldclasssale,
taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
#2.1.3.5 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
zip,
neighborhood,
block,
grosssqft,
landsqft,
yrbuilt,
bldclasssale,
taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
#2.1.3.5 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
zip,
# neighborhood,
# block,
grosssqft,
# landsqft,
yrbuilt,
bldclasssale,
# taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
#  Step 3.
# to get property sold in Q3 and Q4 2020.
q3_2020_sold <- filter(brooklyn_2016_2020_final,
yrsold == "2020", quarter =="3" )
#2.2.1.1 - find the average price of each neighborhood and assign that
# price to price having 0 for those matching neighborhood
unique_neighborhoods <- as.list(unique(brooklyn_2016_2020_final$neighborhood))
unique_zips <- as.list(unique(brooklyn_2016_2020_final$zip))
#2.2.1.2 - Remove duplicates based on columns
#(neighborhood,bldclasscat,block,zip,resunits,totunits,landsqft,
#grosssqft,yrbuilt,bldclasssale,price)
brooklyn_2016_2020_final <- brooklyn_2016_2020_final[
!duplicated(brooklyn_2016_2020_final, by=c('neighborhood',
'bldclasscat',
'block',
'zip',
'resunits',
'totunits',
'landsqft',
'grosssqft',
'yrbuilt',
'bldclasssale',
'price'
)
), ]
#2.2.1.3 - find duplicate rows with same values for column
#(neighborhood,bldclasscat,block,zip,resunits,totunits,landsqft,
#grosssqft,yrbuilt,bldclasssale)
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
group_by(
neighborhood,
address,
bldclasscat,
block,
zip,
resunits,
totunits,
landsqft,
grosssqft,
yrbuilt,
bldclasssale
) %>%
mutate(duplicate_row = case_when(
n()>1  ~ 1,
TRUE  ~ 0
))
brooklyn_2016_2020_final <- func.df.ToInt(
brooklyn_2016_2020_final,list('duplicate_row')
)
#2.2.1.4 - find the average price of each neighborhood and
#corresponding zip and assign that average price to rows
#that has the price between 1 and 10000 for those matching
#neighborhood and zip
func.df.adjPrice <- function(df, neighborhoods, zips) {
df$adjprice = df$price
colname_price = 'adjprice'
colname_neighborhood = 'neighborhood'
colname_zip = 'zip'
group_by_neighbour_zip <- df %>%
filter(is.element(neighborhood, unique_neighborhoods) & price > 3000) %>%
group_by(neighborhood, zip) %>%
summarise(mean_price=floor(mean(price)), .groups = 'drop') %>%
as.data.frame()
for(i in 1:nrow(group_by_neighbour_zip)) {
row <- group_by_neighbour_zip[i,]
col_neighborhood_val <- row[,1]
col_zip_val <- row[,2]
col_mean_price_val <- row[,3]
df[[colname_price]][df[[colname_price]] > 0 &
df[[colname_price]] <= 3000 &
df[[colname_neighborhood]] == col_neighborhood_val &
df[[colname_zip]] == col_zip_val] <- col_mean_price_val
}
return(df)
}
brooklyn_2016_2020_final <- func.df.adjPrice(
brooklyn_2016_2020_final, unique_neighborhoods, unique_zips
)
#2.2.1.5 - Set landsqft = grosssqft if it's 0
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(adjlandsqft = case_when(
landsqft <= 0  ~ grosssqft,
TRUE  ~ landsqft
))
brooklyn_2016_2020_final <-
func.df.ToNum(brooklyn_2016_2020_final,list('adjlandsqft'))
#2.2.2.1 - extract year from sale date
brooklyn_2016_2020_final$yrsold <-
format(brooklyn_2016_2020_final$date,"%Y")
brooklyn_2016_2020_final <-
func.df.ToInt(brooklyn_2016_2020_final,list('yrsold'))
#2.2.3.1 - adding decade as new column. Also as the year build
#increases the house price decreases
brooklyn_2016_2020_final$decade <-
10*floor(brooklyn_2016_2020_final$yrbuilt/10)
brooklyn_2016_2020_final$decade[brooklyn_2016_2020_final$decade<1970] <- 1970
#2.2.3.2 - adding yrbuiltbycategory by dividing the year built
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(yrbuiltbycategory = case_when(
yrbuilt <= 1900  ~ 0,
yrbuilt > 1900 & yrbuilt <= 1970  ~ 1,
yrbuilt > 1970 & yrbuilt <= 2000  ~ 2,
yrbuilt > 2000  ~ 3
))
brooklyn_2016_2020_final <-
func.df.ToInt(brooklyn_2016_2020_final,list('yrbuiltbycategory'))
#2.2.3.3 - adding quarter by extracting month from date
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(quarter = case_when(
is.element(format(date,"%m"), c("01", "02", "03"))  ~ 1,
is.element(format(date,"%m"), c("04", "05", "06"))  ~ 2,
is.element(format(date,"%m"), c("07", "08", "09"))  ~ 3,
is.element(format(date,"%m"), c("10", "11", "12"))  ~ 4
))
brooklyn_2016_2020_final <-
func.df.ToInt(brooklyn_2016_2020_final,list('quarter'))
#2.2.4.1 - group all "A5" "A1" "A9" "A4" "A3" "A2" "A0" "A7" "A6" to "A"
#2.2.4.2 - group all "R3" "R2" "R4" "R1" "R6" "RR" to "R"
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(bldclasssalecategory = case_when(
str_detect(bldclasssale, "^A")  ~ "0",
str_detect(bldclasssale, "^R")  ~ "1"
))
brooklyn_2016_2020_final <- func.df.ToInt(
brooklyn_2016_2020_final,list('bldclasssalecategory')
)
#2.2.5.1 - log transformations of predictors
brooklyn_2016_2020_final$logage <-
log(brooklyn_2016_2020_final$yrsold-brooklyn_2016_2020_final$yrbuilt+0.1)
#2.2.5.4 - Test IID assumptions
#2.3 - Reach a stopping point
#New version of model by adding interaction terms
brooklyn_2016_2020_final.lm.transform.v2 <- lm(formula = adjprice~
factor(bldclasssalecategory)*
grosssqft+
factor(zip)+
logage,
brooklyn_2016_2020_final)
brooklyn_2016_2020_final.lm.transform.v2.summary <-
summary(brooklyn_2016_2020_final.lm.transform.v2)
brooklyn_2016_2020_final.lm.transform.v2.summary
RMSE_transform_v2_model <- sqrt(
mean(brooklyn_2016_2020_final.lm.transform.v2.summary$residuals^2)
)
sprintf("Root Mean Square Error(RMSE) for Transformed V2 Model : %s",
round(RMSE_transform_v2_model, digits = 4))
#  Step 3.
# to get property sold in Q3 and Q4 2020.
q3_2020_sold <- filter(brooklyn_2016_2020_final,
yrsold == "2020", quarter =="3" )
q4_2020_sold <- filter(brooklyn_2016_2020_final,
yrsold == "2020", quarter =="4" )
# average sold price at Q4, USD 1070895.
average_sold_price_q4 <- mean(q4_2020_sold$price)
#  average sold price at Q3, USD 957949.9
average_sold_price_q3 <- mean(q3_2020_sold$price)
# average sold price all property types, quarter 4 over quarter 3.
average_sold_price_change = (
average_sold_price_q4 - average_sold_price_q3)/average_sold_price_q3
# 0.1179029
average_sold_price_change
# number of sold properties
# 339 and 573
q3_count <- nrow(q3_2020_sold)
q4_count <- nrow(q4_2020_sold)
# number of sold properties increase rate
properties_sold_increase_rate <- (q4_count - q3_count)/q3_count
# 0.6902655
properties_sold_increase_rate
# average sold price at Q4, USD 1070895.
average_sold_price_q4 <- mean(q4_2020_sold$price)
#  average sold price at Q3, USD 957949.9
average_sold_price_q3 <- mean(q3_2020_sold$price)
plot(average_sold_price_q4, average_sold_price_q3 )
plot(price~average_sold_price_q4+average_sold_price_q3 )
average_sold_price_q4
average_sold_price_q3
# number of sold properties
# 339 and 573
q3_count <- nrow(q3_2020_sold)
q4_count <- nrow(q4_2020_sold)
q3_count
q4_count
# average sold price all property types, quarter 4 over quarter 3.
average_sold_price_change = (
average_sold_price_q4 - average_sold_price_q3)/average_sold_price_q3
# 0.1179029
average_sold_price_change
# number of sold properties increase rate
properties_sold_increase_rate <- (q4_count - q3_count)/q3_count
# 0.6902655
properties_sold_increase_rate
View(brooklyn_2016_2020_final)
?filter
residential_class_q3 = filter(q3_2020_sold, str_detect(bldclasssale, "^A"))
View(residential_class_q3)
residential_class_q3 <- filter(q3_2020_sold, str_detect(bldclasssale, "^A"))
residential_class_q4 <- filter(q4_2020_sold, str_detect(bldclasssale, "^A"))
# get all types of condo class
condo_class_q3 <- filter(q3_2020_sold, str_detect(bldclasssale, "^R"))
condo_class_q4 <- filter(q4_2020_sold, str_detect(bldclasssale, "^R"))
View(condo_class_q3)
View(condo_class_q4)
# get all types of residential class
residential_class_price_q3 <- filter(q3_2020_sold, str_detect(bldclasssale, "^A"))
residential_class_price_q3
mean(residential_class_price_q3$adjprice)
mean(residential_class_price_q3$price)
mean(residential_class__price_q4$price)
residential_class__price_q4 <- filter(q4_2020_sold, str_detect(bldclasssale, "^A"))
mean(residential_class_price_q3$price)
mean(residential_class__price_q4$price)
(q4_mean - q3_mean)/q4_mean
q4_mean = mean(residential_class__price_q4$price)
(q4_mean - q3_mean)/q4_mean
q3_mean = mean(residential_class_price_q3$price)
q4_mean = mean(residential_class__price_q4$price)
(q4_mean - q3_mean)/q4_mean
condo_class_q3 <- filter(q3_2020_sold, str_detect(bldclasssale, "^R"))
condo_class_q4 <- filter(q4_2020_sold, str_detect(bldclasssale, "^R"))
q3_mean = mean(condo_class_q3$price)
q4_mean = mean(condo_class_q4$price)
(condo_class_q4 - condo_class_q3)/condo_class_q3
# get all types of condo class
condo_class_q3 <- filter(q3_2020_sold, str_detect(bldclasssale, "^R"))
condo_class_q4 <- filter(q4_2020_sold, str_detect(bldclasssale, "^R"))
q3_mean = mean(condo_class_q3$price)
q4_mean = mean(condo_class_q4$price)
(condo_class_q4 - condo_class_q3)/condo_class_q3
q4_mean = mean(condo_class_q4$price)
(q4_mean - q3_mean)/q3_mean
q3_mean
q4_mean
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
# taxclasssale
factor(bldclasssalecategory)* grosssqft,
factor(zip),
logage,
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
# taxclasssale
factor(bldclasssalecategory),
grosssqft,
factor(zip),
logage,
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
# taxclasssale
bldclasssalecategory,
grosssqft,
factor(zip),
logage,
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
?dplyr::select
?melt
?ggplot
?aes
?geom_point
?stat_smooth
?theme_minimal
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
zip,
# neighborhood,
# block,
grosssqft,
# landsqft,
yrbuilt,
bldclasssale,
# taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_classic()
#2.1.3.5 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
zip,
# neighborhood,
# block,
grosssqft,
# landsqft,
yrbuilt,
bldclasssale,
# taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_classic()
brooklyn_2016_2020_final %>%
dplyr::select(c(
price,
zip,
# neighborhood,
# block,
grosssqft,
# landsqft,
yrbuilt,
bldclasssale,
# taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_gray()
