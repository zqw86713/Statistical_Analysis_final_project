missmap(brooklyn_2016_2020_final,col=c('yellow','black'),y.at=1,y.labels='',legend=TRUE)
colSums(is.na(brooklyn_2016_2020_final))
#2.1.1.3 - Data Cleansing — Handle missing data
brooklyn_2016_2020_final[["taxclasscurr"]][str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^A") & is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 1
brooklyn_2016_2020_final[["taxclasscurr"]][str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^R") & is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 2
brooklyn_2016_2020_final[["comunits"]][is.na(brooklyn_2016_2020_final[["comunits"]])] <- 0
brooklyn_2016_2020_final[["taxclasscurr"]][
str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^A")
& is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 1
#2.1.1.3 - Data Cleansing — Handle missing data
brooklyn_2016_2020_final[["taxclasscurr"]][
str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^A")
& is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 1
brooklyn_2016_2020_final[["taxclasscurr"]][
str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^R")
& is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 2
brooklyn_2016_2020_final[["comunits"]][
is.na(brooklyn_2016_2020_final[["comunits"]])] <- 0
ggcorr(
brooklyn_2016_2020_final,
label = T, hjust = 1,
legend.position="top",
layout.exp = 1
)
#2.1.1.5 - visualizing the distribution of the target variable 'price'
brooklyn_2016_2020_final %>%
ggplot(aes(price)) +
stat_density() +
theme_bw()
#2.1.1.6 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(
c(price,
zip,
neighborhood,
block,
grosssqft,
landsqft,
yrbuilt,
bldclasssale,
taxclasssale
)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
#2.1.3.1 - Additionally restrict the data to observation where
#price is greater than 0
brooklyn_2016_2020_final <-
brooklyn_2016_2020_final %>% filter(price > 0 & !is.na(price))
#2.1.3.2 - Additionally restrict the data to observation where
#zip is greater than 0
brooklyn_2016_2020_final <-
brooklyn_2016_2020_final %>% filter(zip > 0)
#2.1.3.3 - visualizing the distribution of the target variable 'price'
brooklyn_2016_2020_final %>%
ggplot(aes(price)) +
stat_density() +
theme_bw()
#2.1.1.3 - Data Cleansing — Handle missing data
brooklyn_2016_2020_final[["taxclasscurr"]][
str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^A")
& is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 1
brooklyn_2016_2020_final[["taxclasscurr"]][
str_detect(brooklyn_2016_2020_final[["bldclasssale"]], "^R")
& is.na(brooklyn_2016_2020_final[["taxclasscurr"]])] <- 2
brooklyn_2016_2020_final[["comunits"]][
is.na(brooklyn_2016_2020_final[["comunits"]])] <- 0
#2.1.3.1 - Additionally restrict the data to observation where
#price is greater than 0
brooklyn_2016_2020_final <-
brooklyn_2016_2020_final %>% filter(price > 0 & !is.na(price))
#2.1.3.2 - Additionally restrict the data to observation where
#zip is greater than 0
brooklyn_2016_2020_final <-
brooklyn_2016_2020_final %>% filter(zip > 0)
#2.1.3.3 - visualizing the distribution of the target variable 'price'
brooklyn_2016_2020_final %>%
ggplot(aes(price)) +
stat_density() +
theme_bw()
#2.1.3.4 - Create a histogram of housing prices
ggplot(data=brooklyn_2016_2020_final) +
geom_histogram(mapping = aes(price))
ggplot(data=brooklyn_2016_2020_final) +
geom_histogram(mapping = aes(price/100000),
breaks=seq(0, 7, by = 1), col="red", fill="lightblue") +
geom_density(mapping = aes(x=price/100000, y = (..count..)))  +
labs(title="Housing Prices in Brooklyn, NY (in $100,000)",
x="Sale Price of Individual Homes/Condos")
ggplot(data=brooklyn_2016_2020_final) + geom_point(mapping= aes(x=grosssqft, y=price))
ggplot(data=brooklyn_2016_2020_final) + geom_point(mapping= aes(x=log(grosssqft), y=price))
#2.1.3.5 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(c(price,zip,neighborhood,block,grosssqft,landsqft,yrbuilt,bldclasssale,taxclasssale)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
#2.1.3.5 - effect of the predictor variables on target variable 'price'
brooklyn_2016_2020_final %>%
dplyr::select(c(price,zip,neighborhood,block,grosssqft,landsqft,yrbuilt,bldclasssale,taxclasssale)) %>%
melt(id.vars = "price") %>%
ggplot(aes(x = value, y = price, colour = variable)) +
geom_point(alpha = 0.7) +
stat_smooth(aes(colour = "black")) +
facet_wrap(~variable, scales = "free", ncol = 2) +
labs(x = "Variable Value", y = "Price ($1000s)") +
theme_minimal()
#2.1.4.1 - check the model summary without any transformation
brooklyn_2016_2020_final.lm.native <- lm(formula = price~
factor(bldclasssale)+
factor(zip)+
grosssqft+
block+
yrbuilt,
brooklyn_2016_2020_final)
brooklyn_2016_2020_final.lm.native.summary <- summary(brooklyn_2016_2020_final.lm.native)
brooklyn_2016_2020_final.lm.native.summary
#get metrics from native model summary
brooklyn_2016_2020_final.lm.native.summary.metric <- data.frame(
R2 = brooklyn_2016_2020_final.lm.native.summary$r.squared,
Adj.R2 = brooklyn_2016_2020_final.lm.native.summary$adj.r.squared
)
RMSE_native_model <- sqrt(mean(brooklyn_2016_2020_final.lm.native.summary$residuals^2))
sprintf("Root Mean Square Error(RMSE) for Native Model : %s", round(RMSE_native_model, digits = 4))
#2.1.4.2 - Diagnostic plots with multiple predictors before transformation
layout(matrix(c(1,2,3,4),2,2)) # optional 4 graphs/page
plot(brooklyn_2016_2020_final.lm.native)
#Kolmogorov-Smirnov test for normality
hist(brooklyn_2016_2020_final.lm.native$residuals)
ks.test(brooklyn_2016_2020_final.lm.native$residuals/summary(brooklyn_2016_2020_final.lm.native)$sigma, pnorm)
#If the p-value of the test is less than some significance level (i.e. α = .05) then we reject the null hypothesis
#and conclude that heteroscedasticity is present in the regression model.
bptest(brooklyn_2016_2020_final.lm.native)
#If the residuals become more spread out at higher values in the plot, this is a tell-tale sign that heteroscedasticity is present.
plot(brooklyn_2016_2020_final.lm.native$fitted.values, brooklyn_2016_2020_final.lm.native$residuals, col = "dodgerblue",
pch = 20, cex = 1.5, xlab = "Fitted", ylab = "Residuals")
abline(h = 0, lty = 2, col = "darkorange", lwd = 2)
#2.2.1.1 - find the average price of each neighborhood and assign that price to price having 0 for those matching neighborhood
unique_neighborhoods <- as.list(unique(brooklyn_2016_2020_final$neighborhood))
#If the p-value of the test is less than some significance level (i.e.
#α = .05) then we reject the null hypothesis
#and conclude that heteroscedasticity is present in the regression model.
bptest(brooklyn_2016_2020_final.lm.native)
#If the residuals become more spread out at higher values in the plot,
#this is a tell-tale sign that heteroscedasticity is present.
plot(brooklyn_2016_2020_final.lm.native$fitted.values, brooklyn_2016_2020_final.lm.native$residuals, col = "dodgerblue",
pch = 20, cex = 1.5, xlab = "Fitted", ylab = "Residuals")
abline(h = 0, lty = 2, col = "darkorange", lwd = 2)
#If the residuals become more spread out at higher values in the plot,
#this is a tell-tale sign that heteroscedasticity is present.
plot(brooklyn_2016_2020_final.lm.native$fitted.values,
brooklyn_2016_2020_final.lm.native$residuals, col = "dodgerblue",
pch = 20, cex = 1.5, xlab = "Fitted", ylab = "Residuals")
abline(h = 0, lty = 2, col = "darkorange", lwd = 2)
#2.2.1.1 - find the average price of each neighborhood and assign that price to price having 0 for those matching neighborhood
unique_neighborhoods <- as.list(unique(brooklyn_2016_2020_final$neighborhood))
#2.2.1.1 - find the average price of each neighborhood and assign that price to price having 0 for those matching neighborhood
unique_neighborhoods <- as.list(unique(brooklyn_2016_2020_final$neighborhood))
#2.2.1.1 - find the average price of each neighborhood and assign that
# price to price having 0 for those matching neighborhood
unique_neighborhoods <- as.list(unique(brooklyn_2016_2020_final$neighborhood))
unique_zips <- as.list(unique(brooklyn_2016_2020_final$zip))
#2.2.1.2 - Remove duplicates based on columns
#(neighborhood,bldclasscat,block,zip,resunits,totunits,landsqft,
#grosssqft,yrbuilt,bldclasssale,price)
brooklyn_2016_2020_final <- brooklyn_2016_2020_final[
!duplicated(brooklyn_2016_2020_final,
by=c('neighborhood','bldclasscat','block',
'zip','resunits','totunits','landsqft',
'grosssqft','yrbuilt','bldclasssale',
'price')
), ]
#2.2.1.3 - find duplicate rows with same values for column
#(neighborhood,bldclasscat,block,zip,resunits,totunits,landsqft,
#grosssqft,yrbuilt,bldclasssale)
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
group_by(
neighborhood,address,bldclasscat,block,zip,resunits,
totunits,landsqft,grosssqft,yrbuilt,bldclasssale) %>%
mutate(duplicate_row = case_when(
n()>1  ~ 1,
TRUE  ~ 0
))
brooklyn_2016_2020_final <- func.df.ToInt(
brooklyn_2016_2020_final,list('duplicate_row')
)
#2.2.1.4 - find the average price of each neighborhood and
#corresponding zip and assign that average price to rows
#that has the price between 1 and 10000 for those matching
#neighborhood and zip
func.df.adjPrice <- function(df, neighborhoods, zips) {
df$adjprice = df$price
colname_price = 'adjprice'
colname_neighborhood = 'neighborhood'
colname_zip = 'zip'
group_by_neighbour_zip <- df %>%
filter(is.element(neighborhood, unique_neighborhoods) & price > 3000) %>%
group_by(neighborhood, zip) %>%
summarise(mean_price=floor(mean(price)), .groups = 'drop') %>%
as.data.frame()
for(i in 1:nrow(group_by_neighbour_zip)) {
row <- group_by_neighbour_zip[i,]
col_neighborhood_val <- row[,1]
col_zip_val <- row[,2]
col_mean_price_val <- row[,3]
df[[colname_price]][df[[colname_price]] > 0 &
df[[colname_price]] <= 3000 &
df[[colname_neighborhood]] == col_neighborhood_val &
df[[colname_zip]] == col_zip_val] <- col_mean_price_val
}
return(df)
}
brooklyn_2016_2020_final <- func.df.adjPrice(brooklyn_2016_2020_final, unique_neighborhoods, unique_zips)
brooklyn_2016_2020_final <- func.df.adjPrice(
brooklyn_2016_2020_final, unique_neighborhoods, unique_zips
)
#2.2.1.5 - Set landsqft = grosssqft if it's 0
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(adjlandsqft = case_when(
landsqft <= 0  ~ grosssqft,
TRUE  ~ landsqft
))
brooklyn_2016_2020_final <-
func.df.ToNum(brooklyn_2016_2020_final,list('adjlandsqft'))
brooklyn_2016_2020_final <-
func.df.ToNum(brooklyn_2016_2020_final,list('adjlandsqft'))
#2.2.2.1 - extract year from sale date
brooklyn_2016_2020_final$yrsold <-
format(brooklyn_2016_2020_final$date,"%Y")
brooklyn_2016_2020_final <-
func.df.ToInt(brooklyn_2016_2020_final,list('yrsold'))
#2.2.3.1 - adding decade as new column. Also as the year build
#increases the house price decreases
brooklyn_2016_2020_final$decade <-
10*floor(brooklyn_2016_2020_final$yrbuilt/10)
brooklyn_2016_2020_final$decade[brooklyn_2016_2020_final$decade<1970] <- 1970
#2.2.3.2 - adding yrbuiltbycategory by dividing the year built
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(yrbuiltbycategory = case_when(
yrbuilt <= 1900  ~ 0,
yrbuilt > 1900 & yrbuilt <= 1970  ~ 1,
yrbuilt > 1970 & yrbuilt <= 2000  ~ 2,
yrbuilt > 2000  ~ 3
))
brooklyn_2016_2020_final$decade[brooklyn_2016_2020_final$decade<1970] <- 1970
#2.2.3.2 - adding yrbuiltbycategory by dividing the year built
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(yrbuiltbycategory = case_when(
yrbuilt <= 1900  ~ 0,
yrbuilt > 1900 & yrbuilt <= 1970  ~ 1,
yrbuilt > 1970 & yrbuilt <= 2000  ~ 2,
yrbuilt > 2000  ~ 3
))
brooklyn_2016_2020_final <-
func.df.ToInt(brooklyn_2016_2020_final,list('yrbuiltbycategory'))
#2.2.4.1 - group all "A5" "A1" "A9" "A4" "A3" "A2" "A0" "A7" "A6" to "A"
#2.2.4.2 - group all "R3" "R2" "R4" "R1" "R6" "RR" to "R"
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(bldclasssalecategory = case_when(
str_detect(bldclasssale, "^A")  ~ "0",
str_detect(bldclasssale, "^R")  ~ "1"
))
#2.2.4.1 - group all "A5" "A1" "A9" "A4" "A3" "A2" "A0" "A7" "A6" to "A"
#2.2.4.2 - group all "R3" "R2" "R4" "R1" "R6" "RR" to "R"
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(bldclasssalecategory = case_when(
str_detect(bldclasssale, "^A")  ~ "0",
str_detect(bldclasssale, "^R")  ~ "1"
))
brooklyn_2016_2020_final <- func.df.ToInt(
brooklyn_2016_2020_final,list('bldclasssalecategory')
)
#2.2.5.1 - log transformations of predictors
brooklyn_2016_2020_final$logage <-
log(brooklyn_2016_2020_final$yrsold-brooklyn_2016_2020_final$yrbuilt+0.1)
#2.2.5.2 - check the model summary after transformations
brooklyn_2016_2020_final.lm.transform.v1 <- lm(formula = adjprice~
factor(bldclasssalecategory)+
factor(zip)+
grosssqft+
factor(decade)+
factor(yrbuiltbycategory)+
block+
logage,
brooklyn_2016_2020_final)
brooklyn_2016_2020_final.lm.transform.v1.summary <- summary(brooklyn_2016_2020_final.lm.transform.v1)
brooklyn_2016_2020_final.lm.transform.v1.summary
RMSE_transform_v1_model <- sqrt(mean(brooklyn_2016_2020_final.lm.transform.v1.summary$residuals^2))
sprintf("Root Mean Square Error(RMSE) for Transformed V1 Model : %s", round(RMSE_transform_v1_model, digits = 4))
#2.2.5.3 - Diagnostic plots with multiple predictors before transformation
layout(matrix(c(1,2,3,4),2,2)) # optional 4 graphs/page
plot(brooklyn_2016_2020_final.lm.transform.v1)
#Kolmogorov-Smirnov test for normality
hist(brooklyn_2016_2020_final.lm.transform.v1$residuals)
ks.test(brooklyn_2016_2020_final.lm.transform.v1$residuals/summary(brooklyn_2016_2020_final.lm.transform.v1)$sigma, pnorm)
#If the p-value of the test is less than some significance level (i.e. α = .05) then we reject the null hypothesis
#and conclude that heteroscedasticity is present in the regression model.
bptest(brooklyn_2016_2020_final.lm.transform.v1)
#If the residuals become more spread out at higher values in the plot, this is a tell-tale sign that heteroscedasticity is present.
plot(fitted(brooklyn_2016_2020_final.lm.transform.v1), resid(brooklyn_2016_2020_final.lm.transform.v1), col = "dodgerblue",
pch = 20, cex = 1.5, xlab = "Fitted", ylab = "Residuals")
#If the residuals become more spread out at higher values in the
#plot, this is a tell-tale sign that heteroscedasticity is present.
plot(fitted(brooklyn_2016_2020_final.lm.transform.v1),
resid(brooklyn_2016_2020_final.lm.transform.v1), col = "dodgerblue",
pch = 20, cex = 1.5, xlab = "Fitted", ylab = "Residuals")
abline(h = 0, lty = 2, col = "darkorange", lwd = 2)
#2.2.5.5 - a scale-location plot
ggplot(brooklyn_2016_2020_final.lm.transform.v1, aes(x=.fitted, y=sqrt(abs(.stdresid)))) +
geom_point() +
geom_hline(yintercept = 0) +
geom_smooth() +
ggtitle("Scale-Location plot : Standardized Residual vs Fitted values")
#2.2.5.6 - normal QQ plot
ggplot(brooklyn_2016_2020_final, aes(sample=brooklyn_2016_2020_final.lm.transform.v1$residuals)) +
stat_qq() +
stat_qq_line() +
labs(title = "QQ Plot of BC Model")
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
logage+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
#2.2.6.2 - New version of model by adding interaction terms from step 2.2.6.1
brooklyn_2016_2020_final.lm.transform.v2 <- lm(formula = adjprice~
factor(bldclasssalecategory)*grosssqft+
factor(zip)+
logage,
brooklyn_2016_2020_final)
#2.2.6.2 - New version of model by adding interaction terms from step 2.2.6.1
brooklyn_2016_2020_final.lm.transform.v2 <- lm(formula = adjprice~
factor(bldclasssalecategory)*
grosssqft+
factor(zip)+
logage,
brooklyn_2016_2020_final)
brooklyn_2016_2020_final.lm.transform.v2.summary <-
summary(brooklyn_2016_2020_final.lm.transform.v2)
brooklyn_2016_2020_final.lm.transform.v2.summary
RMSE_transform_v2_model <- sqrt(mean(brooklyn_2016_2020_final.lm.transform.v2.summary$residuals^2))
sprintf("Root Mean Square Error(RMSE) for Transformed V2 Model : %s", round(RMSE_transform_v2_model, digits = 4))
#2.2.6.2 - New version of model by adding interaction terms from step 2.2.6.1
brooklyn_2016_2020_final.lm.transform.v2 <- lm(formula = adjprice~
factor(bldclasssalecategory)*
grosssqft+
factor(zip)+
logage,
brooklyn_2016_2020_final)
brooklyn_2016_2020_final.lm.transform.v2.summary <-
summary(brooklyn_2016_2020_final.lm.transform.v2)
brooklyn_2016_2020_final.lm.transform.v2.summary
RMSE_transform_v2_model <- sqrt(
mean(brooklyn_2016_2020_final.lm.transform.v2.summary$residuals^2)
)
#2.2.3.3 - adding quarter by extracting month from date
brooklyn_2016_2020_final <- brooklyn_2016_2020_final %>%
mutate(quarter = case_when(
is.element(format(date,"%m"), c("01", "02", "03"))  ~ 1,
is.element(format(date,"%m"), c("04", "05", "06"))  ~ 2,
is.element(format(date,"%m"), c("07", "08", "09"))  ~ 3,
is.element(format(date,"%m"), c("10", "11", "12"))  ~ 4
))
brooklyn_2016_2020_final <- func.df.ToInt(brooklyn_2016_2020_final,list('quarter'))
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
logage+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
#2.2.6.2 - New version of model by adding interaction terms from step 2.2.6.1
brooklyn_2016_2020_final.lm.transform.v2 <- lm(formula = adjprice~
factor(bldclasssalecategory)*
grosssqft+
factor(zip)+
logage,
brooklyn_2016_2020_final)
brooklyn_2016_2020_final.lm.transform.v2.summary <-
summary(brooklyn_2016_2020_final.lm.transform.v2)
brooklyn_2016_2020_final.lm.transform.v2.summary
RMSE_transform_v2_model <- sqrt(
mean(brooklyn_2016_2020_final.lm.transform.v2.summary$residuals^2)
)
sprintf("Root Mean Square Error(RMSE) for Transformed V2 Model : %s",
round(RMSE_transform_v2_model, digits = 4))
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
logage+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
#2.2.6.2 - New version of model by adding interaction terms from step 2.2.6.1
brooklyn_2016_2020_final.lm.transform.v2 <- lm(formula = adjprice~
factor(bldclasssalecategory)*
grosssqft+
factor(zip)+
logage,
brooklyn_2016_2020_final)
brooklyn_2016_2020_final.lm.transform.v2.summary <-
summary(brooklyn_2016_2020_final.lm.transform.v2)
brooklyn_2016_2020_final.lm.transform.v2.summary
RMSE_transform_v2_model <- sqrt(
mean(brooklyn_2016_2020_final.lm.transform.v2.summary$residuals^2)
)
brooklyn_2016_2020_final.lm.transform.v2.summary <-
summary(brooklyn_2016_2020_final.lm.transform.v2)
brooklyn_2016_2020_final.lm.transform.v2.summary
RMSE_transform_v2_model <- sqrt(
mean(brooklyn_2016_2020_final.lm.transform.v2.summary$residuals^2)
)
sprintf("Root Mean Square Error(RMSE) for Transformed V2 Model : %s",
round(RMSE_transform_v2_model, digits = 4))
View(brooklyn_2016_2020_final)
brooklyn_2016_2020_final[yrsold = '2020']
brooklyn_2016_2020_final['yrsold' = '2020']
filter(brooklyn_2016_2020_final, yrsold == "2020")
filter(brooklyn_2016_2020_final, yrsold == "2020", quarter =="3" )
?filter
q3_2020_sold <- mean(
filter(brooklyn_2016_2020_final, yrsold == "2020" & quarter =="3" )
)
q4_2020_sold <- mean(
filter(brooklyn_2016_2020_final, yrsold == "2020" & quarter =="4" )
)
q3_2020_sold <- mean(
filter(brooklyn_2016_2020_final, yrsold == "2020",  quarter =="3" )
)
q3_2020_sold <- filter(brooklyn_2016_2020_final, yrsold == "2020", quarter =="3" )
q4_2020_sold <- filter(brooklyn_2016_2020_final, yrsold == "2020", quarter =="4" )
View(q3_2020_sold)
View(q4_2020_sold)
average_sold_price_change = (q4_2020_sold - q3_2020_sold)/q3_2020_sold
q3_2020_sold <- filter(brooklyn_2016_2020_final, yrsold == "2020", quarter =="3" )
q4_2020_sold <- filter(brooklyn_2016_2020_final, yrsold == "2020", quarter =="4" )
average_sold_price_change = (mean(q4_2020_sold$adjprice) - mean(q3_2020_sold$adjprice))/mean(q3_2020_sold$adjprice)
average_sold_price_change*100
average_sold_price_change
average_sold_price_change = (mean(q4_2020_sold$price)
- mean(q3_2020_sold$price))/mean(q3_2020_sold$price)
average_sold_price_change
# average sold price all property types, quarter 4 over quarter 3
(mean(q4_2020_sold$price)
# average sold price all property types, quarter 4 over quarter 3
mean(q4_2020_sold$price)
# average sold price all property types, quarter 4 over quarter 3
mean(q4_2020_sold$price)
mean(q3_2020_sold$price)
# average sold price all property types, quarter 4 over quarter 3.
# 1070895
average_sold_price_q4 <- mean(q4_2020_sold$price)
# 957949.9
average_sold_price_q3 <- mean(q3_2020_sold$price)
mean(q3_2020_sold$price)
average_sold_price_change = (average_sold_price_q4 - average_sold_price_q3)/average_sold_price_q3
# 0.1179029
average_sold_price_change
# average sold price all property types, quarter 4 over quarter 3.
# 1070895
average_sold_price_q4 <- mean(q4_2020_sold$price)
# 957949.9
average_sold_price_q3 <- mean(q3_2020_sold$price)
mean(q3_2020_sold$price)
average_sold_price_change = (average_sold_price_q4 - average_sold_price_q3)/average_sold_price_q3
# 0.1179029
average_sold_price_change
# number of sold properties
q3_count <- nrow(q3_2020_sold)
q4_count <- nrow(q4_2020_sold)
rate <- (q4_count - q3_count)/q3_count
rate
properties_sold_increase_rate
# number of sold properties increase rate
properties_sold_increase_rate <- (q4_count - q3_count)/q3_count
properties_sold_increase_rate
