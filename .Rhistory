# landsqft,
# grosssqft,
# yrbuilt,
# bldclasssale
) %>%
mutate(duplicate_row = case_when(
n()>1  ~ 1,
TRUE  ~ 0
))
data_2016_2020_clean <- data_2016_2020_clean %>%
group_by(
neighborhood,
address,
bldclasscat,
block,
zip,
resunits,
totunits,
landsqft,
grosssqft,
yrbuilt,
bldclasssale
) %>%
mutate(duplicate_row = case_when(
n()>1  ~ 1,
TRUE  ~ 0
))
?n()
data_2016_2020_clean <- func.df.ToInt(
data_2016_2020_clean,list('duplicate_row')
)
#2.2.1.3 - find duplicate rows with same values for column
#(neighborhood,bldclasscat,block,zip,resunits,totunits,landsqft,
#grosssqft,yrbuilt,bldclasssale)
data_2016_2020_clean <- data_2016_2020_clean %>%
group_by(
neighborhood,
address,
bldclasscat,
block,
zip,
resunits,
totunits,
landsqft,
grosssqft,
yrbuilt,
bldclasssale
) %>%
mutate(duplicate_row = case_when(
n()>1  ~ 1,
TRUE  ~ 0
))
data_2016_2020_clean <- func.df.ToInt(
data_2016_2020_clean,list('duplicate_row')
)
#2.2.1.4 - find the average price of each neighborhood and
#corresponding zip. Some houses are sold with less than 10000 USD,
# we assign the average price from their neighborhood and zip to
# those price-unreasonable houses with those matching neighborhood and zip.
# We create a function to do this.
func.df.adjPrice <- function(df, neighborhoods, zips) {
df$adjprice = df$price
colname_price = 'adjprice'
colname_neighborhood = 'neighborhood'
colname_zip = 'zip'
group_by_neighbour_zip <- df %>%
filter(is.element(neighborhood, unique_neighborhoods) & price > 3000) %>%
group_by(neighborhood, zip) %>%
summarise(mean_price=floor(mean(price)), .groups = 'drop') %>%
as.data.frame()
for(i in 1:nrow(group_by_neighbour_zip)) {
row <- group_by_neighbour_zip[i,]
col_neighborhood_val <- row[,1]
col_zip_val <- row[,2]
col_mean_price_val <- row[,3]
df[[colname_price]][df[[colname_price]] > 0 &
df[[colname_price]] <= 3000 &
df[[colname_neighborhood]] == col_neighborhood_val &
df[[colname_zip]] == col_zip_val] <- col_mean_price_val
}
return(df)
}
#2.2.1.4 - find the average price of each neighborhood and
#corresponding zip. Some houses are sold with less than 3000 USD,
# we assign the average price from their neighborhood and zip to
# those price-unreasonable houses with those matching neighborhood and zip.
# We create a function to do this.
func.df.adjPrice <- function(df, neighborhoods, zips) {
df$adjprice = df$price
colname_price = 'adjprice'
colname_neighborhood = 'neighborhood'
colname_zip = 'zip'
threshold_price=3000
group_by_neighbour_zip <- df %>%
filter(is.element(
neighborhood,
unique_neighborhoods) &
price > threshold_price) %>%
group_by(neighborhood, zip) %>%
summarise(mean_price=floor(mean(price)), .groups = 'drop') %>%
as.data.frame()
for(i in 1:nrow(group_by_neighbour_zip)) {
row <- group_by_neighbour_zip[i,]
col_neighborhood_val <- row[,1]
col_zip_val <- row[,2]
col_mean_price_val <- row[,3]
df[[colname_price]][df[[colname_price]] > 0 &
df[[colname_price]] <= threshold_price &
df[[colname_neighborhood]] == col_neighborhood_val &
df[[colname_zip]] == col_zip_val] <- col_mean_price_val
}
return(df)
}
#2.2.1.4 - find the average price of each neighborhood and
#corresponding zip. Some houses are sold with less than 3000 USD,
# we assign the average price from their neighborhood and zip to
# those price-unreasonable houses with those matching neighborhood and zip.
# We create a function to do this.
func.df.adjPrice <- function(df, neighborhoods, zips) {
df$adjprice = df$price
colname_price = 'adjprice'
colname_neighborhood = 'neighborhood'
colname_zip = 'zip'
threshold_price=3000
group_by_neighbour_zip <- df %>%
filter(is.element(
neighborhood,
unique_neighborhoods) &
price > threshold_price) %>%
group_by(neighborhood, zip) %>%
summarise(mean_price=floor(mean(price)), .groups = 'drop') %>%
as.data.frame()
for(i in 1:nrow(group_by_neighbour_zip)) {
row <- group_by_neighbour_zip[i,]
col_neighborhood_val <- row[,1]
col_zip_val <- row[,2]
col_mean_price_val <- row[,3]
df[[colname_price]][df[[colname_price]] > 0 &
df[[colname_price]] <= threshold_price &
df[[colname_neighborhood]] == col_neighborhood_val &
df[[colname_zip]] == col_zip_val] <- col_mean_price_val
}
return(df)
}
# run the function to fill the adjusted prices to all rows.
data_2016_2020_clean <- func.df.adjPrice(
data_2016_2020_clean,
unique_neighborhoods,
unique_zips
)
#2.2.1.5 - Set landsqft equals grosssqft if landsqft less than 0
data_2016_2020_clean <- data_2016_2020_clean %>%
mutate(adjlandsqft = case_when(
landsqft <= 0  ~ grosssqft,
TRUE  ~ landsqft
))
data_2016_2020_clean <-
func.df.ToNum(data_2016_2020_clean,list('adjlandsqft'))
#2.2.2.1 - extract year from sale date
data_2016_2020_clean$yrsold <-
format(data_2016_2020_clean$date,"%Y")
data_2016_2020_clean <-
func.df.ToInt(data_2016_2020_clean,list('yrsold'))
#2.2.3.2 - convert the column to integer type.
data_2016_2020_clean <-
func.df.ToInt(data_2016_2020_clean,list('yrsold'))
#2.2.3.3 - adding quarter by extracting month from date
data_2016_2020_clean <- data_2016_2020_clean %>%
mutate(quarter = case_when(
is.element(format(date,"%m"), c("01", "02", "03"))  ~ 1,
is.element(format(date,"%m"), c("04", "05", "06"))  ~ 2,
is.element(format(date,"%m"), c("07", "08", "09"))  ~ 3,
is.element(format(date,"%m"), c("10", "11", "12"))  ~ 4
))
#2.2.3.3 - adding quarter by extracting month from date
data_2016_2020_clean <- data_2016_2020_clean %>%
mutate(quarter = case_when(
is.element(format(date,"%m"), c("01", "02", "03"))  ~ 1,
is.element(format(date,"%m"), c("04", "05", "06"))  ~ 2,
is.element(format(date,"%m"), c("07", "08", "09"))  ~ 3,
is.element(format(date,"%m"), c("10", "11", "12"))  ~ 4
))
#2.2.3.4 - convert the column to integer type.
data_2016_2020_clean <-
func.df.ToInt(data_2016_2020_clean,list('quarter'))
#2.2.4.1 - group all "A5" "A1" "A9" "A4" "A3" "A2" "A0" "A7" "A6" to "A"
#2.2.4.2 - group all "R3" "R2" "R4" "R1" "R6" "RR" to "R"
data_2016_2020_clean <- data_2016_2020_clean %>%
mutate(bldclasssalecategory = case_when(
str_detect(bldclasssale, "^A")  ~ "0",
str_detect(bldclasssale, "^R")  ~ "1"
))
data_2016_2020_clean <- func.df.ToInt(
data_2016_2020_clean,list('bldclasssalecategory')
)
# convert the column to int.
data_2016_2020_clean <- func.df.ToInt(
data_2016_2020_clean,list('bldclasssalecategory')
)
#2.2.5.1 - log transformations of predictors
data_2016_2020_clean$log_house_age <-
log(data_2016_2020_clean$yrsold -
data_2016_2020_clean$yrbuilt +
0.1
)
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
#2.2.5.1 - log transformations of predictors
data_2016_2020_clean$log_house_age <-
log(data_2016_2020_clean$yrsold -
data_2016_2020_clean$yrbuilt +
0.1
)
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
#2.2.5.1 - log transformations of predictors
data_2016_2020_clean$log_house_age <-
log(data_2016_2020_clean$yrsold -
data_2016_2020_clean$yrbuilt +
0.1
)
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
#2.2.5.1 - log transformations of predictors
data_2016_2020_clean$log_house_age <-
log(data_2016_2020_clean$yrsold -
data_2016_2020_clean$yrbuilt +
0.1
)
#2.2.5.1 - log transformations of predictors
data_2016_2020_clean$log_house_age <-
log(data_2016_2020_clean$yrsold -
data_2016_2020_clean$yrbuilt +
0.1
)
- Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
brooklyn_2016_2020_final))
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(yrbuiltbycategory)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
data_2016_2020_clean))
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
factor(decade)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
data_2016_2020_clean))
#2.2.6.1 - Let's identify significance level from interaction between variables
summary(lm(formula = adjprice~
(factor(bldclasssalecategory)+
factor(zip)+
grosssqft+
adjlandsqft+
block+
lot+
log_house_age+
yrbuilt+
borough+
factor(bldclasscat)+
factor(taxclasssale))^2,
data_2016_2020_clean))
#2.3.0.1 - Test IID assumptions
#Kolmogorov-Smirnov test for normality
hist(transform.lm$residuals)
#2.3 - Reach a stopping point
#New version of model by adding interaction terms
transform.lm <- lm(formula = adjprice~factor(bldclasssalecategory)*
grosssqft+
factor(zip)+
log_house_age,
data_2016_2020_clean
)
transform.lm.summary <-
summary(transform.lm)
transform.lm.summary
RMSE_transform_v2_model <- sqrt(
mean(transform.lm.summary$residuals^2)
)
sprintf("Root Mean Square Error(RMSE) for Transformed V2 Model : %s",
round(RMSE_transform_v2_model, digits = 4))
#2.3.0.1 - Test IID assumptions
#Kolmogorov-Smirnov test for normality
hist(transform.lm$residuals)
ks.test(transform.lm$residuals/summary(transform.lm)$sigma, pnorm)
#Breusch-Pagan test for normality heteroscedasticity
bptest(transform.lm)
#If the residuals become more spread out at higher values in the plot, this is a tell-tale sign that heteroscedasticity is present.
plot(fitted(transform.lm), resid(transform.lm), col = "dodgerblue",
pch = 20, cex = 1.5, xlab = "Fitted", ylab = "Residuals")
abline(h = 0, lty = 2, col = "darkorange", lwd = 2)
#2.3.0.1 - Test IID assumptions
#Kolmogorov-Smirnov test for normality
hist(transform.lm$residuals)
ks.test(transform.lm$residuals/summary(transform.lm)$sigma, pnorm)
#Breusch-Pagan test for normality heteroscedasticity
bptest(transform.lm)
#If the residuals become more spread out at higher values in the plot,
#this is a tell-tale sign that heteroscedasticity is present.
plot(fitted(transform.lm),
resid(transform.lm),
col = "dodgerblue",
pch = 20, cex = 1.5,
xlab = "Fitted",
ylab = "Residuals")
plot(fitted(transform.lm),
resid(transform.lm),
col = "dodgerblue",
pch = 40, cex = 1.5,
xlab = "Fitted",
ylab = "Residuals")
#If the residuals become more spread out at higher values in the plot,
#this is a tell-tale sign that heteroscedasticity is present.
plot(fitted(transform.lm),
resid(transform.lm),
col = "dodgerblue",
pch = 20, cex = 1.5,
xlab = "Fitted",
ylab = "Residuals")
abline(h = 0, lty = 2, col = "darkorange", lwd = 2)
#2.3.0.1 - Test IID assumptions
#Kolmogorov-Smirnov test for normality
hist(transform.lm$residuals)
ks.test(transform.lm$residuals/summary(transform.lm)$sigma, pnorm)
#Breusch-Pagan test for normality heteroscedasticity
bptest(transform.lm)
#If the residuals become more spread out at higher values in the plot,
#this is a tell-tale sign that heteroscedasticity is present.
plot(fitted(transform.lm),
resid(transform.lm),
col = "dodgerblue",
pch = 20, cex = 1.5,
xlab = "Fitted",
ylab = "Residuals")
abline(h = 0, lty = 2, col = "darkorange", lwd = 2)
#2.2.5.5 - a scale-location plot
ggplot(transform.lm, aes(x=.fitted, y=sqrt(abs(.stdresid)))) +
geom_point() +
geom_hline(yintercept = 0) +
geom_smooth() +
ggtitle("Scale-Location plot : Standardized Residual vs Fitted values")
#2.2.5.5 - a scale-location plot
ggplot(transform.lm,
aes(x=.fitted, y=sqrt(abs(.stdresid)))) +
geom_point() +
geom_hline(yintercept = 0) +
geom_smooth() +
ggtitle("Scale-Location plot : Standardized Residual vs Fitted values")
#2.2.5.6 - normal QQ plot
ggplot(data_2016_2020_clean, aes(sample=transform.lm$residuals)) +
stat_qq() +
stat_qq_line() +
labs(title = "QQ Plot of BC Model")
#  Step 3.
# to get property sold in Q3 and Q4 2020.
q3_2020_sold <- filter(data_2016_2020_clean,
yrsold == "2020", quarter =="3" )
q4_2020_sold <- filter(data_2016_2020_clean,
yrsold == "2020", quarter =="4" )
# average sold price at Q4, USD 1070895.
average_sold_price_q4 <- mean(q4_2020_sold$price)
#  average sold price at Q3, USD 957949.9
average_sold_price_q3 <- mean(q3_2020_sold$price)
# average sold price all property types, quarter 4 over quarter 3.
average_sold_price_change = (
average_sold_price_q4 - average_sold_price_q3)/average_sold_price_q3
# 0.1179029
average_sold_price_change
# number of sold properties
# 339 and 573
q3_count <- nrow(q3_2020_sold)
q4_count <- nrow(q4_2020_sold)
# number of sold properties increase rate
properties_sold_increase_rate <- (q4_count - q3_count)/q3_count
# 0.6902655
properties_sold_increase_rate
# get all types of residential class
residential_class_price_q3 <- filter(q3_2020_sold, str_detect(bldclasssale, "^A"))
residential_class__price_q4 <- filter(q4_2020_sold, str_detect(bldclasssale, "^A"))
q3_mean = mean(residential_class_price_q3$price)
q4_mean = mean(residential_class__price_q4$price)
(q4_mean - q3_mean)/q4_mean
# get all types of condo class
condo_class_q3 <- filter(q3_2020_sold, str_detect(bldclasssale, "^R"))
condo_class_q4 <- filter(q4_2020_sold, str_detect(bldclasssale, "^R"))
q3_mean = mean(condo_class_q3$price)
q4_mean = mean(condo_class_q4$price)
(q4_mean - q3_mean)/q3_mean
# Step 3: Submit model and work.
saveRDS(list(model=transform.lm,
data=data_2016_2020_clean),
file="qingwei_zhang.RDS"
)
